#!/usr/bin/env sh

VERSION="0.9.3"

exec awk -v "Version=$VERSION" -f - Makesurefile "$@" <<'MAKESURE'

BEGIN {
    Shell = "bash" # default shell
    SupportedShells["bash"]
    SupportedShells["sh"]
    SupportedOptions["tracing"]
    SupportedOptions["silent"]
    SupportedOptions["timing"]
    prepare_args()
}

NR==1 && /^#!/      { next }
"@options"    == $1 { handle_options();     next }
"@define"     == $1 { handle_define();      next }
"@shell"      == $1 { handle_shell();       next }
"@goal"       == $1 { handle_goal();        next }
"@doc"        == $1 { handle_doc();         next }
"@depends_on" == $1 { handle_depends_on();  next }
"@reached_if" == $1 { handle_reached_if();  next }
                    { handle_code_line($0); next }

END { if (!Died) do_work() }

function prepare_args(    i,arg) {
    for (i = 0; i < ARGC; i++) {
        arg = ARGV[i]
        #print i " " arg
        if (i > 1) {
            if (substr(arg,1,1) == "-") {
                if (arg == "-f" || arg == "--file") {
                  delete ARGV[i]
                  ARGV[1] = ARGV[++i]
                } else
                  Args[arg]
            } else
                arr_push(ArgGoals, arg)

            delete ARGV[i] # https://unix.stackexchange.com/a/460375
        }
    }
    if (system("test -f \"" ARGV[1] "\"") != 0)
      die_msg("makesure file not found: " ARGV[1])
    if ("-v" in Args || "--version" in Args) {
        print Version
        Died = 1
        exit 0
    }
    if ("-s" in Args || "--silent" in Args)
      Options["silent"]
    if ("-x" in Args || "--tracing" in Args)
      Options["tracing"]
    if ("-t" in Args || "--timing" in Args)
      Options["timing"]
    #print "--- ARGV: "; for (i in ARGV) print i " : " ARGV[i]
    #print "--- Args: "; for (i in Args) print i " : " Args[i]
    #print "--- ArgGoals: "; for (i in ArgGoals) print i " : " ArgGoals[i]
}

function handle_options() {
    check_prelude_only()

    for (i=2; i<=NF; i++) {
        if (!($i in SupportedOptions))
          die("Option " $i " is not supported")
        Options[$i]
    }
}

function handle_define() {
    check_prelude_only()

    $1 = "export"
    handle_code_line($0)
}

function handle_shell() {
    check_prelude_only()

    Shell = trim($2)

    if (!(Shell in SupportedShells))
      die("Shell '" Shell "' is not supported")
}

function handle_goal(    goal_name) {
    goal_name = trim($2)
    if (length(goal_name) == 0) {
        die("Goal must have a name")
    }
    if (goal_name in GoalsByName) {
        die("Goal " goal_name " is already defined")
    }
    arr_push(GoalNames, goal_name)
    GoalsByName[goal_name]
}

function handle_doc(    goal_name) {
    check_goal_only()

    goal_name = current_goal_name()

    $1 = ""
    Doc[goal_name, DocCnt[goal_name]++] = trim($0)
}

function handle_depends_on(    goal_name,i) {
    check_goal_only()

    goal_name = current_goal_name()

    for (i=2; i<=NF; i++) {
        Dependencies[goal_name, DependenciesCnt[goal_name]++] = $i
    }
}

function handle_reached_if(    goal_name) {
    check_goal_only()

    goal_name = current_goal_name()

    if (goal_name in ReachedIf) {
        die("Multiple " $1 " not allowed for a goal")
    }

    $1 = ""
    ReachedIf[goal_name] = trim($0)
}

function do_work(    i,j,goal_name,dep_cnt,dep,reached_if_condition,script,my_dir,body,prelude_body,goal_body,goal_bodies,resolved_goals,cmd,exit_code) {
    script = ""
    
    if ("tracing" in Options)
        script = issue_line(script, "set -x")

    my_dir = ""
    my_dir = issue_line(my_dir, "MYDIR='" get_my_dir() "'")
    my_dir = issue_line(my_dir, "export MYDIR")
    my_dir = issue_line(my_dir, "cd \"$MYDIR\"")

    # prelude
    body = trim(code[""])
    prelude_body = body
    script = issue_line(script, my_dir prelude_body)

    for (i = 0; i < arr_len(GoalNames); i++) {
        goal_name = GoalNames[i]

        body = trim(code[goal_name])

        script = issue_line(script, "\n" goal_name "() {")

        reached_if_condition = ReachedIf[goal_name]

        # check valid dependencies
        dep_cnt = DependenciesCnt[goal_name]
        for (j=0; j < dep_cnt; j++) {
            dep = Dependencies[goal_name, j]
            if (!(dep in GoalsByName))
                die_msg("Goal '" goal_name "' has unknown dependency '" dep "'") # TODO find a way to provide line reference
            if (!(reached_if_condition ? check_condition_reached(prelude_body, reached_if_condition) : false)) {
                #print " [not reached] " goal_name " -> " dep
                topological_sort_add_connection(goal_name, dep)
            } else {
                #print " [    reached] " goal_name " -> " dep
            }
        }

        if (length(body) == 0) {
            # in shell function can't have empty body - use nop
            body = ":"
        }

        script = issue_line(script, "\n" Shell " -e <<'EOF'")

        goal_body = ""
        if (!("silent" in Options)) {
            goal_body = issue_line(goal_body, "  printf \"  goal '" goal_name "' \"")
        }
        goal_body = issue_line(goal_body, "  if " (reached_if_condition ? reached_if_condition : "false") "; then")
        if (!("silent" in Options)) {
            goal_body = issue_line(goal_body, "    echo \"[already satisfied].\"")
        }
        goal_body = issue_line(goal_body, "    exit 0")
        if (!("silent" in Options)) {
            goal_body = issue_line(goal_body, "  else")
            goal_body = issue_line(goal_body, "    echo \"" (body == ":" ? "[empty]." : "...") "\"")
        }
        goal_body = issue_line(goal_body, "  fi")

        if ("tracing" in Options)
            goal_body = issue_line(goal_body, "set -x")

        goal_body = issue_line(goal_body, "  " body)
        goal_bodies[goal_name] = goal_body

        script = issue_line(script, goal_body "EOF\n")
        script = issue_line(script, "}")
    }

    script = issue_resolved_goals_to_run(script, resolved_goals)

    if ("-d" in Args || "--resolved" in Args) {
        printf("Resolved goals to reach for '%s':\n", join(ArgGoals, 0, arr_len(ArgGoals), " "))
        for (i = 0; i < arr_len(resolved_goals); i++) {
           print "  " resolved_goals[i]
        }
    } else if ("-l" in Args || "--list" in Args) {
        print "Available goals:"
        for (i = 0; i < arr_len(GoalNames); i++) {
            goal_name = GoalNames[i]
            print "  " goal_name
            if (goal_name in DocCnt) {
              for (j = 0; j < DocCnt[goal_name]; j++)
                print "    " Doc[goal_name, j]
            }
        }
    } else if ("-p" in Args || "--print" in Args) {
        print script
    } else {
        # exit shell_exec(script, "EOF_OUTER")
        for (i = 0; i < arr_len(resolved_goals); i++) {
          goal_name = resolved_goals[i]
          goal_body = goal_bodies[goal_name]
          exit_code = shell_exec(my_dir prelude_body "\n" goal_body)
          if (exit_code != 0)
            exit exit_code
        }
    }
}

function issue_resolved_goals_to_run(script, result,    i, goal_name, loop) {
    if (arr_len(ArgGoals) == 0)
        arr_push(ArgGoals, "default")

    for (i = 0; i < arr_len(ArgGoals); i++) {
        goal_name = ArgGoals[i]
        if (!(goal_name in GoalsByName)) {
            die_msg("Goal not found: " goal_name) # TODO can we show line number here?
        }
        topological_sort_perform(goal_name, result, loop)
    }

    if (loop[0] == 1) {
        die_msg("There is a loop in goal dependencies via " loop[1] " -> " loop[2])
    }

    script = issue_line(script, "__resolved_goals() {")
    for (i = 0; i < arr_len(result); i++) {
       script = issue_line(script, "  " result[i])
    }
    script = issue_line(script, "}")
    script = issue_line(script, "__resolved_goals")
    return script
}

function issue_line(script, line) {
    return script line "\n"
}

function is_prelude() {
    return arr_len(GoalNames) == 0
}

function check_prelude_only() {
    if (!is_prelude()) {
        die("Only use " $1 " in prelude")
    }
}

function check_goal_only() {
   if (is_prelude()) {
       die("Only use " $1 " in goal")
   }
}

function current_goal_name() {
    return is_prelude() ? "" : GoalNames[arr_len(GoalNames)-1] # TODO arr_index via slice
}

function die(msg) {
    die_msg(msg ":\n" ARGV[1] ":" NR ": " $0)
}

function die_msg(msg,    out) {
    out = "cat 1>&2" # trick to write from awk to stderr
    print msg | out
    close(out)
    Died = 1
    exit 1
}

function check_condition_reached(prelude_body, condition_str,    script) {
    script = prelude_body # need this to initialize variables for check conditions
    script = script "\n" condition_str
    return shell_exec(script) == 0
}

function shell_exec(script, eof,    s, res) {
    if (!eof)
        eof = "EOF"

    s = Shell " -e <<'" eof "'"
    s = s "\n" script
    s = s "\n" eof
    #print s
    res = system(s)
    #print "res " res
    return res
}

function get_my_dir(    script, res) {
  script = Shell " -e <<'EOF'"
  script = script "\n" sprintf("echo \"$(cd \"$(dirname %s)\"; pwd)\"", FILENAME)
  script = script "\nEOF"
  script | getline res
  close(script)
  return res
}

function handle_code_line(line,    goal_name, current_code) {
    goal_name = current_goal_name()
    #print "Append line for '" goal_name "': " line
    current_code = code[goal_name]
    code[goal_name] = current_code ? current_code "\n" line : line
}

function topological_sort_add_connection(from, to) {
    # slist - list of successors by node
    # scnt - count of successors by node
    slist[from, ++scnt[from]] = to # add 'to' to successors of 'from'
}

function topological_sort_perform(node, result, loop,    i, s) {
    if (visited[node] == 2)
        return

    visited[node] = 1

    for (i = 1; i <= scnt[node]; i++) {
        if (visited[s = slist[node, i]] == 0)
            topological_sort_perform(s, result, loop)
        else if (visited[s] == 1) {
            loop[0] = 1
            loop[1] = s
            loop[2] = node
        }
    }

    visited[node] = 2

    arr_push(result, node)
}

function current_time_millis(    script, res) {
  script = "date +%s%3N"
  script | getline res
  close(script)
  sub(/%3N/, "000", res) # if date doesn't support %N (macos?) just use second-precision
  return res + 0
}
function render_duration(deltaMillis,
#
deltaSec,deltaMin,deltaHr,deltaDay,
dayS,hrS,minS,secS,secSI,
res) {
  deltaSec = deltaMillis / 1000
  deltaMin = 0
  deltaHr = 0
  deltaDay = 0

  if (deltaSec >= 60) {
    deltaMin = int(deltaSec / 60)
    deltaSec = deltaSec - deltaMin * 60
  }

  if (deltaMin >= 60) {
    deltaHr = int(deltaMin / 60)
    deltaMin = deltaMin - deltaHr * 60
  }

  if (deltaHr >= 24) {
    deltaDay = int(deltaHr / 24)
    deltaHr = deltaHr - deltaDay * 24
  }

  dayS = deltaDay > 0 ? deltaDay " d" : ""
  hrS = deltaHr > 0 ? deltaHr " h" : ""
  minS = deltaMin > 0 ? deltaMin " m" : ""
  secS = deltaSec > 0 ? deltaSec " s" : ""
  secSI = deltaSec > 0 ? int(deltaSec) " s" : ""

  if (dayS != "")
    res = dayS " " (hrS == "" ? "0 h" : hrS)
  else if (deltaHr > 0)
    res = hrS " " (minS == "" ? "0 m" : minS)
  else if (deltaMin > 0)
    res = minS " " (secSI == "" ? "0 s" : secSI)
  else
    res = deltaSec > 0 ? secS : "0 s"

  return res
}
function join(arr, start_incl, end_excl, sep,    result, i) {
    result = arr[start_incl]
    for (i = start_incl + 1; i < end_excl; i++)
        result = result sep arr[i]
    return result
}
function arr_push(arr, elt) { arr[arr[-7]++] = elt }
function arr_len(arr) { return arr[-7] }
function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
function trim(s) { return rtrim(ltrim(s)); }

MAKESURE
