#!/usr/bin/env sh

VERSION="0.9.2"

exec awk -v "Version=$VERSION" -f - Makesurefile "$@" <<'MAKESURE'

BEGIN {
    CurrentGoalIdx = -1
    GoalNames[-1] = "" # prelude
    Shell = "bash" # default shell
    SupportedShells["bash"]
    SupportedShells["sh"]
    prepare_args()
}

NR==1 && /^#!/      { next }
"@define"     == $1 { handle_define();      next }
"@shell"      == $1 { handle_shell();       next }
"@goal"       == $1 { handle_goal();        next }
"@doc"        == $1 { handle_doc();         next }
"@depends_on" == $1 { handle_depends_on();  next }
"@reached_if" == $1 { handle_reached_if();  next }
                    { handle_code_line($0); next }

END { if (!Died) do_work() }

function prepare_args(    i,arg) {
    for (i = 0; i < ARGC; i++) {
        arg = ARGV[i]
        #print i " " arg;
        if (i > 1) {
            if (substr(arg,1,1) == "-") {
                if (arg == "-f" || arg == "--file") {
                  delete ARGV[i]
                  ARGV[1] = ARGV[++i]
                } else
                  Args[arg] = 1
            } else
                ArgsGoals[ArgGoalsCnt++] = arg
            delete ARGV[i] # https://unix.stackexchange.com/a/460375
        }
    }
    if (system("test -f \"" ARGV[1] "\"") != 0)
      die_msg("makesure file not found: " ARGV[1])
    if ("-v" in Args || "--version" in Args) {
        print Version
        Died = 1
        exit 0
    }
    if ("-x" in Args)
      Tracing = 1
    if ("-t" in Args || "--timing" in Args)
      Timing = 1
    #print "--- ARGV: "; for (i in ARGV) print i " : " ARGV[i]
    #print "--- Args: "; for (i in Args) print i " : " Args[i]
    #print "--- ArgsGoals: "; for (i in ArgsGoals) print i " : " ArgsGoals[i]
}

function handle_define() {
    check_prelude_only()

    $1 = "export"
    handle_code_line($0)
}

function handle_shell() {
    check_prelude_only()

    Shell = trim($2)

    if (!(Shell in SupportedShells))
      die("Shell '" Shell "' is not supported")
}

function handle_goal(    goal_name) {
    goal_name = trim($2)
    if (length(goal_name) == 0) {
        die("Goal must have a name")
    }
    if (goal_name in GoalsByName) {
        die("Goal " goal_name " is already defined")
    }
    CurrentGoalIdx++
    GoalNames[CurrentGoalIdx] = goal_name
    GoalsByName[goal_name] = 1
}

function handle_doc(    goal_name) {
    check_goal_only()

    goal_name = current_goal_name()

    $1 = ""
    Doc[goal_name, DocCnt[goal_name]++] = trim($0)
}

function handle_depends_on(    goal_name,i) {
    check_goal_only()

    goal_name = current_goal_name()

    for (i=2; i<=NF; i++) {
        Dependencies[goal_name, DependenciesCnt[goal_name]++] = $i
    }
}

function handle_reached_if(    goal_name) {
    check_goal_only()

    goal_name = current_goal_name()

    if (goal_name in ReachedIf) {
        die("Multiple " $1 " not allowed for a goal")
    }

    $1 = ""
    ReachedIf[goal_name] = trim($0)
}

function do_work(    i,j,goal_name,dep_cnt,dep,reached_if_condition,body,prelude_body,resolved_goals,cmd) {
    if (Tracing)
        issue_script_line("set -x")

    issue_script_line("MYDIR='" get_my_dir() "'")
    issue_script_line("export MYDIR")
    issue_script_line("cd \"$MYDIR\"")

    for (i = -1; i <= CurrentGoalIdx; i++) {
        goal_name = GoalNames[i]

        body = trim(code[goal_name])

        if (length(goal_name) != 0) {
            issue_script_line("\n" goal_name "() {")

            reached_if_condition = ReachedIf[goal_name]

            # check valid dependencies
            dep_cnt = DependenciesCnt[goal_name]
            for (j=0; j < dep_cnt; j++) {
                dep = Dependencies[goal_name, j]
                if (!(dep in GoalsByName))
                    die_msg("Goal '" goal_name "' has unknown dependency '" dep "'") # TODO find a way to provide line reference
                if (!(reached_if_condition ? check_condition_reached(prelude_body, reached_if_condition) : false)) {
                    #print " [not reached] " goal_name " -> " dep
                    topological_sort_add_connection(goal_name, dep)
                } else {
                    #print " [    reached] " goal_name " -> " dep
                }
            }

            if (length(body) == 0) {
                # in shell function can't have empty body - use nop
                body = ":"
            }

            issue_script_line("\n" Shell " -e <<'EOF'")
            issue_script_line("  printf \"  goal '" goal_name "' \"")
            issue_script_line("  if " (reached_if_condition ? reached_if_condition : "false") "; then")
            issue_script_line("    echo \"[already satisfied].\"")
            issue_script_line("    exit 0")
            issue_script_line("  else")
            issue_script_line("    echo \"" (body == ":" ? "[empty]." : "...") "\"")
            issue_script_line("  fi")
            if (Tracing)
                issue_script_line("set -x")
            issue_script_line("  " body)
            issue_script_line("EOF\n")

            issue_script_line("}")
        } else { # prelude
            prelude_body = body
            issue_script_line(body)
        }
    }

    issue_resolved_goals_to_run(resolved_goals)

    if ("-d" in Args || "--resolved" in Args) {
        printf("Resolved goals to reach for '%s':\n", join(ArgsGoals, 0, ArgGoalsCnt-1, " "))
        for (i = 1; i <= array_len(resolved_goals); i++) {
           print "  " resolved_goals[i]
        }
    } else if ("-l" in Args || "--list" in Args) {
        print "Available goals:"
        for (i = 0; i <= CurrentGoalIdx; i++) {
            print "  " GoalNames[i]
            if (GoalNames[i] in DocCnt) {
              for (j = 0; j < DocCnt[GoalNames[i]]; j++)
                print "    " Doc[GoalNames[i], j]
            }
        }
    } else if ("-p" in Args || "--print" in Args) {
        print Script
    } else {
        cmd = Shell " -e"
        print Script | cmd
        if (close(cmd) != 0)
            exit 1
    }
}

function issue_resolved_goals_to_run(result,    i, g, loop) {
    if (ArgGoalsCnt == 0)
        ArgsGoals[ArgGoalsCnt++] = "default"

    for (i in ArgsGoals) {
        g = ArgsGoals[i]
        if (!(g in GoalsByName)) {
            die_msg("Goal not found: " g) # TODO can we show line number here?
        }
        topological_sort_perform(g, result, loop)
    }

    if (loop[0] == 1) {
        die_msg("There is a loop in goal dependencies via " loop[1] " -> " loop[2])
    }

    issue_script_line("__resolved_goals() {")
    for (i = 1; i <= array_len(result); i++) {
       issue_script_line("  " result[i])
    }
    issue_script_line("}")
    issue_script_line("__resolved_goals")
}

function issue_script_line(line) {
    Script = Script line "\n";
}

function is_prelude() {
    return CurrentGoalIdx < 0
}

function check_prelude_only() {
    if (!is_prelude()) {
        die("Only use " $1 " in prelude")
    }
}

function check_goal_only() {
   if (is_prelude()) {
       die("Only use " $1 " in goal")
   }
}

function current_goal_name() {
    return CurrentGoalIdx == -1 ? "" : GoalNames[CurrentGoalIdx]
}

function die(msg) {
    die_msg(msg ":\n" ARGV[1] ":" NR ": " $0)
}

function die_msg(msg,    out) {
    out = "cat 1>&2" # trick to write from awk to stderr
    print msg | out
    close(out)
    Died = 1
    exit 1
}

function check_condition_reached(prelude_body, condition_str,    script, res) {
    script = Shell " -e <<'EOF'"
    script = script "\n" prelude_body # need this to initialize variables for check conditions
    script = script "\n" condition_str
    script = script "\nEOF"
    #print script
    res = system(script)
    #print "res " res
    return res == 0
}

function get_my_dir(    script, res) {
  script = Shell " -e <<'EOF'"
  script = script "\n" sprintf("echo \"$(cd \"$(dirname %s)\"; pwd)\"", FILENAME)
  script = script "\nEOF"
  script | getline res
  close(script)
  return res
}

function handle_code_line(line,    goal_name, current_code) {
    goal_name = current_goal_name()
    #print "Append line for '" goal_name "': " line
    current_code = code[goal_name]
    code[goal_name] = current_code ? current_code "\n" line : line
}

function topological_sort_add_connection(from, to) {
    # slist - list of successors by node
    # scnt - count of successors by node
    slist[from, ++scnt[from]] = to # add 'to' to successors of 'from'
}

function topological_sort_perform(node, result, loop,    i, s) {
    if (visited[node] == 2)
        return

    visited[node] = 1

    for (i = 1; i <= scnt[node]; i++) {
        if (visited[s = slist[node, i]] == 0)
            topological_sort_perform(s, result, loop)
        else if (visited[s] == 1) {
            loop[0] = 1
            loop[1] = s
            loop[2] = node
        }
    }

    visited[node] = 2

    array_push(result, node)
}

function join(array, start, end, sep,    result, i) {
    result = array[start]
    for (i = start + 1; i <= end; i++)
        result = result sep array[i]
    return result
}

function array_push(arr, elt) { arr[++arr[0]] = elt }
function array_len(arr) { return arr[0] }
function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
function trim(s) { return rtrim(ltrim(s)); }

MAKESURE
